#pragma once

#include<algorithm>
#include<cstdarg>
#include<deque>
#include<mutex>
#include<numeric>
#include<regex>
#include<string>
#include<thread>
#include<unordered_map>

#include "Automaton.hh"
#include "DTAnd.hh"
#include "DTNCReps.hh"
#include "DTNext.hh"
#include "DTNextAnd.hh"
#include "Hstring.hh"
#include "Location.hh"
#include "PermGenerator.hh"
#include "Semaphore.hh"
#include "Trace.hh"
#include "Trinary.hh"
#include "exp.hh"


namespace harm{


class Template{
  public: 

  /** \brief Constructor
   * \param templateFormula representation of a template as a PSL formula
   * \param max_length length of the trace
   */
  Template(Hstring &templateFormula, harm::Trace *trace, DTLimits limits);

  /** \brief Copy Constructor
   */
  Template(const Template &original);

  ~Template();

/** \brief evaluates the assertion generated by loading the propositions in the template 
 *  \param time trace instant on which to evaluate the assertion 
*/
  Trinary evaluate(site_t time);


  public :
    /// pointer to input trace 
    harm::Trace *_trace;

    /// lenght of the trace
    size_t _max_length;

  private:
    /// dt operator configuration
    DTLimits _limits;

    /// current employed templated
    Hstring _templateFormula;

    /// original templated with the dt operator uninstantiated
    Hstring _buildTemplateFormula;

    /// used to generate the permutations
    PermGenerator _pg;

    /// link of all placeholders to all instantiated propositions
    std::unordered_map<std::string, Proposition **> _tokenProp;

    ///link of all user instantiated placeholders to their respective propositions
    std::unordered_map<std::string, Proposition **> _iToProp;

    ///links all the dt operators to their respective propositions
    std::pair<std::string, DTOperator *> _dtOp = {"",nullptr};

     ///_aphToProp + _cphToProp + _acphToProp == _phToProp
    std::map<std::string, Proposition **> _aphToProp;
    std::map<std::string, Proposition **> _cphToProp;
    std::map<std::string, Proposition **> _acphToProp;

    /* current proposition domains:
      the generator of permutations will use the following propositions to
      generate the permutations
      */
    ///used by the generator of permutations to generate the permutations
    std::vector<Proposition *> _aProps;
    std::vector<Proposition *> _cProps;
    std::vector<Proposition *> _acProps;
  
  
  };


}